1.vm.$set(vm.list, 1, 'lemon');  设置数组
2.vm.$set(vm.info, 'name', 'female');  设置对象{}, 如果对象里有name就修改参数，如果没有添加参数
3.arr.some(item){return 条件}  返回 true false

9.jquery  里的$.ajax(url: 'http://localhost:3000/data',success: function(data) {console.log(data)})
10.let p = new Promise(funciton(resole,reject){if(3>2){resole('正确')}else{reject('错误')}})，resole执行true|reject执行false,Promise会返回给p,通过p.then(function(data){console(data)}) "不够严谨"还需要function(info){console.log(info)}接受误差处理


vue 的不懂的地方
axios,过滤器,跨域 $on,watch，mapstate,mapgetter,router,过渡动画，keep-alive

vue
vue.extend()构建组件
v-自定义方法   在vue内设置directive
computed       计算机属性,在html中{{映射出来}}，主要有缓存，后期会被getters替代
watch          监视,

属性
event.target   当前dom，看看跟ref有什么不同
:disabled="flag"   当前的input是否被激活，flag是data里的属性
keep-alive: 被包裹在keep-alive中的组件的状态将会被保留，例如我们将某个列表类组件内容滑动到第100条位置，那么我们在切换到一个组件后再次切换回到该组件，该组件的位置状态依旧会保持在第100条列表处




            





子组件获取父组件data, props  在父组件中子组件的标签里:子组件变量=“父组件变量”,然后在子组件里用props，接受子组件变量，然后在标签里{{子组件变量}}
子组件获取父组件事件, $emit  在父组件中子组件的标签里@子组件事件=“父组件事件”,然后在子组件methods里用$emit("子组件事件",参数)
ref的用法    先在html里ref="id" 然后在vue里用$refs.id,能获取这个dom，如果是refs是获取全部带ref属性的dom
vue.set(target, key, value)  target:要更改的data参数，key:再次定位data参数里的索引，value改变后的参数
                             比如items: [{mag:"zs",id:1},{mag:"ls",id:2},{mag:"ww",id:3}],然后在methods方法里用vue.set(this.items,0,{mag:"zs",id:'10'}) ==>  items: [{mag:"zs",id:10},{mag:"ls",id:2},{mag:"ww",id:3}]

插槽 slot,如果父组件里有参数，那就会导入到slot标签里     https://www.jianshu.com/p/cb6209b10070
     v-slot,首先在子组件里设定name="名字"但标签是slot,然后父组件里<template v-slot:名字>参数</template>，只能导入一次,最后一次有效
	 子组件里绑定data参数，然后在父组件里<template #参数名="slotProps">slotprops是接受的数值接受的是数组,在父组件里{{slotProps}}释放
	 v-slot有缩写#
     slot作用域,在子组件里slot 带属性,然后父组件里接收<template slot-scope="接收的参数名">接收的数据为数组，其实跟上面的一样



router
this.$route.params 获取url，在路由中设置props:true,可以省略$router.params ==> 比如获取路径上/home/page1,id就为page1 ==> this.id就行了   
beforeRouteUpdate(to,from,next)

vuex
引用:import store文件，然后跟router一样放入vue内
state     是存放静态属性， {{this.$states.count}} 可以访问count属性，但是最好不要这样做
getters   跟计算机属性一样，具有监听的功能，在store中getStateCount: function(state){return state.count+1}   然后在子组件中映射{{this.$store.getters.getStateCount}}
mutations 方法  mutations里的方法add(state){state.count++;}， 然后在引入到组件方法里this.$store.commit("add"), 然后放入html里
actions   vue不建议直接在子组件中用this.$store.commit("add"),而是在actions中用，addFun(context){context.commit("add")},然后在放入子组件中addFun(){this.$store.dispatch("add")}
          具体流程: 首先在state中设置参数，然后在mutations中设置方法，然后在actions再次包装方法，然后在放入子组件的方法里在再次包装

mapstate  先在子组件导入import { mapState } from 'vuex'

		  

关于scss的语法
scoped是样式仅限于局部
导入: @import './xxx';
引用: @include sc(0.55rem, #666)    @mixin sc($size, $color){font-size: $size;color: $color;}  也可以设置默认参数              
      border-top: 1px solid $bc;    $bc: #fff;
	  
	  
属性
中间空格justify-content:space-between;
align-items: center;
fill: #999;
首行缩进text-indent:0.45rem;